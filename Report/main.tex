\documentclass[12pt,a4paper]{article}

% Paquetes esenciales
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{subcaption}
\usepackage{float}
\usepackage{geometry}

\geometry{margin=2.5cm}

% Configuración de colores para código
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

% Teoremas y definiciones
\newtheorem{definition}{Definición}[section]
\newtheorem{theorem}{Teorema}[section]
\newtheorem{lemma}[theorem]{Lema}
\newtheorem{corollary}[theorem]{Corolario}
\newtheorem{proposition}[theorem]{Proposición}

% Información del documento
\title{
    \large Problema de Transporte Logístico Discreto\\
    \vspace{0.5cm}
    \large Diseño y Análisis de Algoritmos
}
\author{
    Richard Alejandro Matos Arderí \\
    Abel Ponce González \\
    Abraham Romero Imbert \\
    \vspace{0.5cm} \\
    Facultad de Matemática y Computación \\
    Universidad de La Habana
}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Este informe presenta un estudio completo del problema de \textit{Balanced Multi-Bin Packing with Capacity Constraints}, un problema de optimización combinatoria NP-hard con aplicaciones en logística y distribución de cargas. Se desarrolla la formalización matemática del problema, se demuestra su complejidad computacional mediante reducción desde 3-PARTITION, y se implementan múltiples enfoques algorítmicos incluyendo algoritmos greedy, programación dinámica, branch and bound, y metaheurísticas (Simulated Annealing, Algoritmos Genéticos, Búsqueda Tabú). Se presenta además un análisis experimental comparativo de los algoritmos implementados.
\end{abstract}

\tableofcontents
\newpage

%=============================================================================
\section{Introducción}
%=============================================================================

\subsection{Motivación}

El problema de empaquetamiento balanceado en múltiples contenedores surge en numerosas aplicaciones prácticas de logística y distribución. Considérese el escenario de una empresa de transporte que debe distribuir $n$ paquetes en $k$ vehículos, donde cada vehículo tiene una capacidad máxima de peso y se desea equilibrar la carga de trabajo (medida en valor o tiempo de entrega) entre todos los vehículos.

A diferencia del problema clásico de bin packing que busca minimizar el número de contenedores, nuestro problema tiene un número fijo de contenedores y busca:
\begin{enumerate}
    \item Respetar las restricciones de capacidad de peso
    \item Minimizar el desbalance de valores entre contenedores
\end{enumerate}

\subsection{Objetivos del Proyecto}

Los objetivos principales de este proyecto son:
\begin{itemize}
    \item Formalizar matemáticamente el problema
    \item Demostrar su complejidad computacional (NP-hardness)
    \item Implementar y analizar múltiples enfoques algorítmicos
    \item Desarrollar herramientas de visualización y benchmarking
    \item Crear un dashboard interactivo para experimentación
\end{itemize}

%=============================================================================
\section{Definición Formal del Problema}
%=============================================================================

\subsection{Notación y Definiciones}

\begin{definition}[Ítem]
Un ítem $i \in I$ se caracteriza por un par $(w_i, v_i)$ donde:
\begin{itemize}
    \item $w_i \in \mathbb{R}^+$: peso del ítem
    \item $v_i \in \mathbb{R}^+$: valor del ítem
\end{itemize}
\end{definition}

\begin{definition}[Contenedor (Bin)]
Un contenedor $j \in \{1, \ldots, k\}$ tiene una capacidad máxima individual $C_j \in \mathbb{R}^+$. Cada contenedor puede tener una capacidad diferente.
\end{definition}

\begin{definition}[Asignación]
Una asignación es una función $\sigma: I \rightarrow \{1, \ldots, k\}$ que mapea cada ítem a un contenedor.
\end{definition}

\begin{definition}[Asignación Factible]
Una asignación $\sigma$ es factible si y solo si:
\[
\forall j \in \{1, \ldots, k\}: \sum_{i: \sigma(i) = j} w_i \leq C_j
\]
donde $C_j$ es la capacidad específica del contenedor $j$.
\end{definition}

\subsection{Formulación del Problema}

\textbf{Entrada:}
\begin{itemize}
    \item Conjunto de ítems $I = \{1, 2, \ldots, n\}$
    \item Peso $w_i > 0$ y valor $v_i \geq 0$ para cada ítem $i \in I$
    \item Número de contenedores $k \in \mathbb{Z}^+$
    \item Capacidad individual $C_j > 0$ para cada contenedor $j \in \{1, \ldots, k\}$
\end{itemize}

\textbf{Variable de Decisión:}
\[
x_{ij} = \begin{cases}
1 & \text{si el ítem } i \text{ es asignado al contenedor } j\\
0 & \text{en otro caso}
\end{cases}
\]

\textbf{Objetivo:} Minimizar el \textit{makespan} (valor máximo entre contenedores):
\[
\min z = \max_{j=1}^{k} \sum_{i=1}^{n} v_i \cdot x_{ij}
\]

O equivalentemente, minimizar la diferencia máxima:
\[
\min \left( \max_{j} V_j - \min_{j} V_j \right)
\]

donde $V_j = \sum_{i: \sigma(i)=j} v_i$ es el valor total del contenedor $j$.

\subsection{Formulación como Programa Lineal Entero (ILP)}

\begin{align}
\text{minimizar} \quad & z \\
\text{sujeto a:} \quad & \sum_{j=1}^{k} x_{ij} = 1 & \forall i \in I \label{eq:assignment}\\
& \sum_{i=1}^{n} w_i \cdot x_{ij} \leq C_j & \forall j = 1, \ldots, k \label{eq:capacity}\\
& \sum_{i=1}^{n} v_i \cdot x_{ij} \leq z & \forall j = 1, \ldots, k \label{eq:makespan}\\
& x_{ij} \in \{0, 1\} & \forall i \in I, j = 1, \ldots, k \label{eq:binary}\\
& z \geq 0 &
\end{align}

Donde:
\begin{itemize}
    \item (\ref{eq:assignment}): Cada ítem debe asignarse a exactamente un contenedor
    \item (\ref{eq:capacity}): Restricción de capacidad por peso (cada contenedor $j$ tiene capacidad $C_j$)
    \item (\ref{eq:makespan}): Definición del makespan
    \item (\ref{eq:binary}): Variables binarias de decisión
\end{itemize}

%=============================================================================
\section{Análisis de Complejidad}
%=============================================================================

\subsection{Clases de Complejidad y el Problema de Decisión}

Antes de analizar la complejidad de nuestro problema, es fundamental distinguir entre problemas de optimización y problemas de decisión.

\begin{definition}[Problema de Optimización vs. Decisión]
\begin{itemize}
    \item \textbf{Problema de Optimización (BALANCED-BIN-PACKING-OPT):} 
    
    Dados $n$ ítems con pesos y valores, $k$ bins con capacidades $C_1, \ldots, C_k$, encontrar una asignación factible que minimice la diferencia máxima de valores entre bins.
    
    \item \textbf{Problema de Decisión (BALANCED-BIN-PACKING-DEC):}
    
    Dados $n$ ítems con pesos y valores, $k$ bins con capacidades $C_1, \ldots, C_k$, y un umbral $B$, ¿existe una asignación factible tal que la diferencia máxima de valores entre bins sea $\leq B$?
\end{itemize}
\end{definition}

\begin{proposition}
Si el problema de decisión BALANCED-BIN-PACKING-DEC está en NP, entonces el problema de optimización BALANCED-BIN-PACKING-OPT está en NPO (problemas de optimización NP).
\end{proposition}

\subsection{NP-Completitud del Problema de Decisión}

\begin{theorem}[NP-Completitud de BALANCED-BIN-PACKING-DEC]
El problema de decisión BALANCED-BIN-PACKING-DEC es NP-completo.
\end{theorem}

\begin{proof}
Demostraremos que BALANCED-BIN-PACKING-DEC $\in$ NP-completo mediante dos pasos:

\textbf{Paso 1: BALANCED-BIN-PACKING-DEC $\in$ NP}

Un certificado para una instancia con respuesta 'sí' es una asignación $\sigma: I \rightarrow \{1, \ldots, k\}$. La verificación requiere:
\begin{enumerate}
    \item Verificar que cada ítem está asignado: $O(n)$
    \item Calcular peso total de cada bin: $O(n)$
    \item Verificar restricciones de capacidad: $O(k)$
    \item Calcular valor total de cada bin: $O(n)$
    \item Verificar que $\max_j V_j - \min_j V_j \leq B$: $O(k)$
\end{enumerate}

Total: $O(n + k)$, por lo tanto el certificado es verificable en tiempo polinomial. $\square$

\textbf{Paso 2: NP-Hardness mediante reducción desde 3-PARTITION}

\end{proof}

\subsection{Cadena de Reducciones: De PARTITION a Nuestro Problema}

Para comprender mejor la dureza del problema, presentamos la cadena de reducciones desde problemas fundamentales:

\begin{center}
\textbf{Cadena de Reducciones Polinomiales:}

\vspace{0.5cm}

PARTITION $\leq_p$ 3-PARTITION $\leq_p$ BIN PACKING $\leq_p$ BALANCED-BIN-PACKING

\vspace{0.5cm}


\end{center}

\subsubsection{Problema PARTITION (Punto de Partida)}

\begin{definition}[PARTITION]
\textbf{Entrada:} Conjunto $S = \{a_1, a_2, \ldots, a_n\}$ de enteros positivos.

\textbf{Pregunta:} ¿Existe un subconjunto $S' \subseteq S$ tal que $\sum_{a_i \in S'} a_i = \sum_{a_i \in S \setminus S'} a_i = \frac{1}{2}\sum_{a_i \in S} a_i$?
\end{definition}

PARTITION es uno de los 21 problemas originales de Karp (1972) demostrados NP-completos.

\subsubsection{Reducción 1: PARTITION $\leq_p$ 3-PARTITION}

\begin{definition}[3-PARTITION]
\textbf{Entrada:} Conjunto $A = \{a_1, a_2, \ldots, a_{3m}\}$ de $3m$ enteros positivos y un entero $B$ tal que:
\begin{itemize}
    \item $\sum_{i=1}^{3m} a_i = mB$
    \item $\frac{B}{4} < a_i < \frac{B}{2}$ para todo $i$
\end{itemize}

\textbf{Pregunta:} ¿Se puede particionar $A$ en $m$ conjuntos disjuntos $A_1, \ldots, A_m$ tal que cada $A_i$ contiene exactamente 3 elementos y $\sum_{a \in A_i} a = B$?
\end{definition}

\textbf{Importancia:} 3-PARTITION es \textit{fuertemente NP-completo}, lo que significa que permanece NP-completo incluso si los números se representan en unario (Garey \& Johnson, 1979).

\subsubsection{Reducción 2: 3-PARTITION $\leq_p$ BALANCED-BIN-PACKING}

\begin{lemma}[Reducción desde 3-PARTITION]
3-PARTITION se reduce polinomialmente a BALANCED-BIN-PACKING-DEC.
\end{lemma}

\begin{proof}
Dada una instancia de 3-PARTITION con elementos $\{a_1, \ldots, a_{3m}\}$ y objetivo $B$, construimos una instancia de BALANCED-BIN-PACKING-DEC:

\textbf{Construcción:}
\begin{enumerate}
    \item Para cada elemento $a_i$, creamos un ítem con:
    \begin{itemize}
        \item Peso: $w_i = a_i$
        \item Valor: $v_i = a_i$ (peso y valor coinciden)
    \end{itemize}
    
    \item Número de bins: $k = m$
    
    \item Capacidad de cada bin: $C_j = B$ para $j = 1, \ldots, m$ (capacidades uniformes)
    
    \item Umbral de balance: $\beta = 0$ (buscamos balance perfecto)
\end{enumerate}

\textbf{Correctitud ($\Rightarrow$):}

Supongamos que existe una 3-partición válida $A_1, \ldots, A_m$ de los elementos originales.

Construimos una asignación $\sigma$ para BALANCED-BIN-PACKING:
\begin{itemize}
    \item Para cada conjunto $A_j$ en la 3-partición, asignamos los ítems correspondientes al bin $j$
    \item Cada bin $j$ contiene exactamente 3 ítems con peso total $B$
    \item Por construcción ($v_i = w_i$), el valor total de cada bin es también $B$
    \item La diferencia máxima de valores es: $\max_j V_j - \min_j V_j = B - B = 0 \leq \beta$
\end{itemize}

Por lo tanto, la asignación es factible y satisface el umbral de balance.

\textbf{Correctitud ($\Leftarrow$):}

Supongamos que existe una asignación factible $\sigma$ para BALANCED-BIN-PACKING con diferencia $\leq 0$.

Esto implica que todos los bins tienen el mismo valor total. Como:
\begin{itemize}
    \item Suma total de valores: $\sum_{i=1}^{3m} v_i = \sum_{i=1}^{3m} a_i = mB$
    \item Número de bins: $k = m$
    \item Todos los bins tienen igual valor
\end{itemize}

Cada bin debe tener valor exactamente $\frac{mB}{m} = B$.

Dado que $v_i = w_i$ y el bin tiene capacidad $B$, cada bin también tiene peso total $B$ (está completamente lleno).

Las restricciones $\frac{B}{4} < a_i < \frac{B}{2}$ garantizan que:
\begin{itemize}
    \item Ningún bin puede tener menos de 3 elementos (ya que $3 \times \frac{B}{4} > \frac{3B}{4}$ pero necesitamos llegar a $B$)
    \item Ningún bin puede tener más de 3 elementos (ya que $4 \times \frac{B}{4} = B$ pero cada elemento es $> \frac{B}{4}$)
\end{itemize}

Por lo tanto, cada bin contiene exactamente 3 elementos que suman $B$, constituyendo una 3-partición válida. $\square$
\end{proof}

\subsection{Implicaciones de la NP-Completitud}

\begin{corollary}
El problema de optimización BALANCED-BIN-PACKING-OPT es NP-hard.
\end{corollary}

\begin{proof}
Si existiera un algoritmo polinomial para BALANCED-BIN-PACKING-OPT, podríamos resolver BALANCED-BIN-PACKING-DEC en tiempo polinomial:
\begin{enumerate}
    \item Ejecutar el algoritmo de optimización
    \item Comparar el resultado con $B$
    \item Responder 'sí' si resultado $\leq B$, 'no' en caso contrario
\end{enumerate}

Como BALANCED-BIN-PACKING-DEC es NP-completo, esto implicaría P = NP. $\square$
\end{proof}


\subsection{Problema con Capacidades Heterogéneas}

\begin{proposition}
El problema BALANCED-BIN-PACKING con capacidades heterogéneas (diferentes $C_j$ por bin) es al menos tan difícil como el caso con capacidades uniformes.
\end{proposition}

\begin{proof}
El caso uniforme es una instancia particular del caso heterogéneo (cuando $C_1 = C_2 = \cdots = C_k$). 

Si existiera un algoritmo polinomial para el caso heterogéneo, también resolvería el caso uniforme en tiempo polinomial, lo cual contradice la NP-hardness del caso uniforme (asumiendo P $\neq$ NP). $\square$
\end{proof}

\subsection{Complejidad de los Algoritmos Implementados}

\begin{table}[H]
\centering
\caption{Complejidad temporal y espacial de los algoritmos implementados}
\begin{tabular}{lcc}
\toprule
\textbf{Algoritmo} & \textbf{Tiempo} & \textbf{Espacio} \\
\midrule
First Fit Decreasing (FFD) & $O(n \log n + n \cdot k)$ & $O(n + k)$ \\
Best Fit Decreasing (BFD) & $O(n \log n + n \cdot k)$ & $O(n + k)$ \\
Worst Fit Decreasing (WFD) & $O(n \log n + n \log k)$ & $O(n + k)$ \\
LPT Balanced & $O(n \log n + n \log k)$ & $O(n + k)$ \\
Programación Dinámica & $O(k \cdot 3^n)$ & $O(k \cdot 2^n)$ \\
Branch and Bound & $O(k^n)$ peor caso & $O(n \cdot k)$ \\
Simulated Annealing & $O(I \cdot n)$ & $O(n)$ \\
Genetic Algorithm & $O(G \cdot P \cdot n)$ & $O(P \cdot n)$ \\
Tabu Search & $O(I \cdot N)$ & $O(n + T)$ \\
\bottomrule
\end{tabular}
\label{tab:complexity}
\end{table}

Donde:
\begin{itemize}
    \item $n$: número de ítems
    \item $k$: número de contenedores (bins)
    \item $I$: número de iteraciones
    \item $G$: número de generaciones
    \item $P$: tamaño de población
    \item $N$: tamaño del vecindario
    \item $T$: tamaño de la lista tabú
\end{itemize}

%=============================================================================
\section{Algoritmos Implementados}
%=============================================================================

\subsection{Algoritmos Greedy}

\subsubsection{First Fit Decreasing (FFD)}

El algoritmo FFD ordena los ítems por peso decreciente y asigna cada ítem al primer contenedor que tiene capacidad suficiente.

\begin{algorithm}[H]
\caption{First Fit Decreasing}
\begin{algorithmic}[1]
\Procedure{FFD}{$items, k, C_1, \ldots, C_k$}
    \State $sorted\_items \gets \text{sort}(items, \text{key}=weight, \text{desc}=True)$
    \State $bins \gets [\ ] \times k$ \Comment{Crear $k$ bins con capacidades $C_j$}
    \For{$item \in sorted\_items$}
        \For{$j \gets 1$ \textbf{to} $k$}
            \If{$\text{weight}(bins[j]) + item.weight \leq C_j$}
                \State $bins[j].\text{add}(item)$
                \State \textbf{break}
            \EndIf
        \EndFor
    \EndFor
    \State \Return $bins$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsubsection{LPT Balanced}

El algoritmo Longest Processing Time (LPT) adaptado para balanceo asigna cada ítem al contenedor con menor carga actual, respetando las capacidades individuales.

\begin{algorithm}[H]
\caption{LPT Balanced}
\begin{algorithmic}[1]
\Procedure{LPT}{$items, k, C_1, \ldots, C_k$}
    \State $sorted\_items \gets \text{sort}(items, \text{key}=value, \text{desc}=True)$
    \State $bins \gets [\ ] \times k$ \Comment{Bins con capacidades individuales}
    \For{$item \in sorted\_items$}
        \State $j^* \gets \arg\min_{j: \text{weight}(bins[j]) + item.weight \leq C_j} \text{value}(bins[j])$
        \State $bins[j^*].\text{add}(item)$
    \EndFor
    \State \Return $bins$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Branch and Bound}

El algoritmo de Branch and Bound explora sistemáticamente el espacio de soluciones utilizando cotas para podar ramas no prometedoras.

\begin{algorithm}[H]
\caption{Branch and Bound}
\begin{algorithmic}[1]
\Procedure{BranchAndBound}{$items, k, C_1, \ldots, C_k$}
    \State $best \gets \infty$
    \State $best\_solution \gets \text{null}$
    \State $queue \gets \{(\emptyset, items)\}$ \Comment{(asignación parcial, ítems restantes)}
    
    \While{$queue \neq \emptyset$}
        \State $(partial, remaining) \gets queue.\text{pop}()$
        
        \If{$remaining = \emptyset$}
            \State $obj \gets \text{objective}(partial)$
            \If{$obj < best$}
                \State $best \gets obj$
                \State $best\_solution \gets partial$
            \EndIf
        \Else
            \State $item \gets remaining[0]$
            \For{$j \gets 1$ \textbf{to} $k$}
                \If{$\text{weight}(partial[j]) + item.weight \leq C_j$}
                    \State $new\_partial \gets \text{assign}(partial, j, item)$
                    \State $lb \gets \text{lower\_bound}(new\_partial, remaining[1:])$
                    \If{$lb < best$} \Comment{Pruning}
                        \State $queue.\text{push}((new\_partial, remaining[1:]))$
                    \EndIf
                \EndIf
            \EndFor
        \EndIf
    \EndWhile
    
    \State \Return $best\_solution$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Programación Dinámica}

La programación dinámica resuelve el problema de forma óptima para instancias pequeñas, construyendo soluciones incrementalmente usando memoización.

\subsubsection{Esquema SRTBOT}

Presentamos la formulación completa de nuestro algoritmo de programación dinámica utilizando el esquema SRTBOT (Subproblemas, Relación de recurrencia, Topología, Base, Original, Tiempo):

\textbf{S - Subproblemas:}

Definimos el subproblema $DP[j][mask]$ como la mejor solución (mínima diferencia entre valores máximo y mínimo) para asignar los ítems indicados por la máscara de bits $mask$ a los primeros $j$ contenedores, respetando las capacidades $C_1, \ldots, C_j$.

Formalmente:
\begin{itemize}
    \item $mask \in \{0, 1, \ldots, 2^n - 1\}$: subconjunto de ítems asignados (representado como máscara de bits)
    \item $j \in \{1, \ldots, k\}$: número de contenedores utilizados
    \item $DP[j][mask] = (V_{max}, V_{min}, assignment)$ donde:
    \begin{itemize}
        \item $V_{max}$: valor máximo entre los $j$ contenedores
        \item $V_{min}$: valor mínimo entre los $j$ contenedores
        \item $assignment$: lista de máscaras indicando asignación por contenedor
    \end{itemize}
\end{itemize}

Número de subproblemas: $O(k \cdot 2^n)$

\textbf{R - Relación de Recurrencia:}

Para cada subproblema $DP[j][mask]$, consideramos todos los subconjuntos $S$ de los ítems restantes que son factibles para el contenedor $j$:

\[
DP[j][mask \cup S] = \min_{\substack{S \subseteq remaining \\ S \in Factible(j)}} \]

\[\left\{ \max\left(DP[j-1][mask].V_{max}, V(S)\right) - \min\left(DP[j-1][mask].V_{min}, V(S)\right) \right\}
\]

donde:
\begin{itemize}
    \item $remaining = (\text{full\_mask}) \oplus mask$: ítems aún no asignados
    \item $Factible(j) = \{S : \sum_{i \in S} w_i \leq C_j\}$: subconjuntos que caben en contenedor $j$
    \item $V(S) = \sum_{i \in S} v_i$: valor total del subconjunto $S$
\end{itemize}

\textbf{T - Topología (Orden de Resolución):}

Los subproblemas se resuelven en el siguiente orden:
\begin{enumerate}
    \item Pre-computación: calcular $Factible(j)$ para cada $j \in \{1, \ldots, k\}$
    \item Ordenar por número de contenedores: $j = 1, 2, \ldots, k$
    \item Para cada $j$, iterar sobre máscaras $mask$ en orden creciente de cardinalidad (número de bits en 1)
\end{enumerate}

Este orden garantiza que cuando calculamos $DP[j][mask]$, ya tenemos calculados todos los valores $DP[j-1][mask']$ necesarios donde $mask' \subset mask$.

\textbf{B - Casos Base:}

\begin{itemize}
    \item $DP[1][S] = (V(S), V(S), [S])$ para todo $S \in Factible(1)$
    
    Es decir, con un solo contenedor, la diferencia es 0 (solo hay un valor) y el estado almacena el valor del único contenedor.
    
    \item $DP[j][\emptyset] = (\infty, 0, [])$ representa el estado inicial sin ítems asignados (no válido para solución final)
\end{itemize}

\textbf{O - Problema Original:}

El problema original corresponde a:
\[
DP[k][full\_mask]
\]

donde $full\_mask = 2^n - 1$ representa el conjunto de todos los ítems.

El valor objetivo óptimo es:
\[
z^* = DP[k][full\_mask].V_{max} - DP[k][full\_mask].V_{min}
\]

\textbf{T - Tiempo de Ejecución:}

\begin{itemize}
    \item \textbf{Pre-computación de subconjuntos factibles:}
    \[
    O(k \cdot 2^n \cdot n)
    \]
    Para cada contenedor, evaluamos $2^n$ subconjuntos, y cada evaluación de peso/valor toma $O(n)$.
    
    \item \textbf{Llenado de tabla DP:}
    
    Para cada estado $(j, mask)$, debemos iterar sobre todos los subconjuntos de $remaining = full\_mask \oplus mask$. El número total de operaciones es:
    \[
    \sum_{mask} 2^{|remaining|} = \sum_{m=0}^{n} \binom{n}{m} \cdot 2^{n-m} = (1+2)^n = 3^n
    \]
    
    Multiplicando por $k$ contenedores: $O(k \cdot 3^n)$
    
    \item \textbf{Espacio:} $O(k \cdot 2^n)$ para almacenar la tabla DP
    
    \item \textbf{Complejidad Total:} $O(k \cdot 3^n)$ tiempo, $O(k \cdot 2^n)$ espacio
\end{itemize}

\subsubsection{Enfoque con Capacidades Heterogéneas}

Para el caso con capacidades individuales por contenedor, utilizamos un enfoque de DP basado en subconjuntos factibles por bin.

\textbf{Idea Principal:}
\begin{enumerate}
    \item Pre-computar todos los subconjuntos factibles de ítems para cada contenedor
    \item Usar DP para encontrar la mejor k-partición de ítems
    \item Estado: $DP[j][mask]$ = mejor solución usando $j$ bins y asignando ítems en $mask$
\end{enumerate}

\begin{algorithm}[H]
\caption{Programación Dinámica para Multi-Bin Balancing}
\begin{algorithmic}[1]
\Procedure{DynamicProgramming}{$items, k, C_1, \ldots, C_k$}
    \State $n \gets |items|$
    \State $feasible[j] \gets \{\}$ para $j = 1, \ldots, k$
    
    \Comment{Pre-computar subconjuntos factibles para cada bin}
    \For{$j \gets 1$ \textbf{to} $k$}
        \For{$mask \gets 0$ \textbf{to} $2^n - 1$}
            \State $total\_weight \gets 0, total\_value \gets 0$
            \For{$i \gets 0$ \textbf{to} $n-1$}
                \If{$mask \& (1 << i)$}
                    \State $total\_weight \gets total\_weight + items[i].weight$
                    \State $total\_value \gets total\_value + items[i].value$
                \EndIf
            \EndFor
            \If{$total\_weight \leq C_j$}
                \State $feasible[j][mask] \gets (total\_weight, total\_value)$
            \EndIf
        \EndFor
    \EndFor
    
    \Comment{DP: $dp[j][mask]$ = (max\_val, min\_val, assignment)}
    \State $dp[1] \gets \{\}$
    \For{$mask \in feasible[1]$}
        \State $v \gets feasible[1][mask].value$
        \State $dp[1][mask] \gets (v, v, [mask])$
    \EndFor
    
    \Comment{Llenar tabla DP}
    \For{$j \gets 2$ \textbf{to} $k$}
        \State $dp[j] \gets \{\}$
        \For{$prev\_mask \in dp[j-1]$}
            \State $(prev\_max, prev\_min, prev\_assign) \gets dp[j-1][prev\_mask]$
            \State $remaining \gets \text{full\_mask} \oplus prev\_mask$
            
            \For{$subset \in \text{subsets}(remaining) \cap feasible[j]$}
                \State $new\_mask \gets prev\_mask \mid subset$
                \State $new\_value \gets feasible[j][subset].value$
                \State $new\_max \gets \max(prev\_max, new\_value)$
                \State $new\_min \gets \min(prev\_min, new\_value)$
                \State $new\_diff \gets new\_max - new\_min$
                
                \If{$new\_mask \notin dp[j]$ \textbf{or} $new\_diff < dp[j][new\_mask].diff$}
                    \State $dp[j][new\_mask] \gets (new\_max, new\_min, prev\_assign + [subset])$
                \EndIf
            \EndFor
        \EndFor
    \EndFor
    
    \State $full\_mask \gets 2^n - 1$
    \State \Return $dp[k][full\_mask].assignment$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\textbf{Complejidad:}
\begin{itemize}
    \item Pre-computación: $O(k \cdot 2^n \cdot n)$
    \item DP principal: $O(k \cdot 3^n)$ (iterar sobre particiones)
    \item Espacio: $O(k \cdot 2^n)$
\end{itemize}

La complejidad $O(3^n)$ surge del hecho de que para cada máscara, debemos iterar sobre todos sus subconjuntos, lo cual es $\sum_{|S|=m} \binom{n}{m} 2^m = 3^n$ por el teorema del binomio.

\textbf{Optimizaciones Implementadas:}
\begin{enumerate}
    \item Poda de estados dominados
    \item Límite en el tamaño de instancia ($n \leq 20$)
    \item Fallback a algoritmo greedy para instancias grandes
\end{enumerate}

\subsection{Metaheurísticas}

\subsubsection{Simulated Annealing}

\begin{algorithm}[H]
\caption{Simulated Annealing}
\begin{algorithmic}[1]
\Procedure{SA}{$problem, T_0, \alpha, max\_iter$}
    \State $current \gets \text{initial\_solution}(problem)$
    \State $best \gets current$
    \State $T \gets T_0$
    
    \For{$i \gets 1$ \textbf{to} $max\_iter$}
        \State $neighbor \gets \text{generate\_neighbor}(current)$
        \State $\Delta \gets f(neighbor) - f(current)$
        
        \If{$\Delta < 0$ \textbf{or} $\text{random}() < e^{-\Delta/T}$}
            \State $current \gets neighbor$
            \If{$f(current) < f(best)$}
                \State $best \gets current$
            \EndIf
        \EndIf
        
        \State $T \gets \alpha \cdot T$ \Comment{Enfriamiento}
    \EndFor
    
    \State \Return $best$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsubsection{Algoritmo Genético}

\begin{algorithm}[H]
\caption{Algoritmo Genético}
\begin{algorithmic}[1]
\Procedure{GA}{$problem, pop\_size, generations, p_c, p_m$}
    \State $population \gets \text{initialize\_population}(pop\_size)$
    
    \For{$g \gets 1$ \textbf{to} $generations$}
        \State $fitness \gets \text{evaluate}(population)$
        \State $new\_pop \gets \emptyset$
        
        \While{$|new\_pop| < pop\_size$}
            \State $parent_1, parent_2 \gets \text{tournament\_select}(population, fitness)$
            
            \If{$\text{random}() < p_c$}
                \State $child_1, child_2 \gets \text{crossover}(parent_1, parent_2)$
            \Else
                \State $child_1, child_2 \gets parent_1, parent_2$
            \EndIf
            
            \If{$\text{random}() < p_m$}
                \State $child_1 \gets \text{mutate}(child_1)$
                \State $child_2 \gets \text{mutate}(child_2)$
            \EndIf
            
            \State $new\_pop \gets new\_pop \cup \{child_1, child_2\}$
        \EndWhile
        
        \State $population \gets new\_pop$
    \EndFor
    
    \State \Return $\text{best}(population)$
\EndProcedure
\end{algorithmic}
\end{algorithm}

%=============================================================================
\section{Estructura del Proyecto}
%=============================================================================

\subsection{Arquitectura de Módulos}

El proyecto está organizado en los siguientes módulos principales:

\begin{verbatim}
discrete_logistics/
+-- core/
|   +-- problem.py          # Estructuras de datos
|   +-- instance_generator.py
+-- algorithms/
|   +-- base.py             # Clase abstracta Algorithm
|   +-- greedy.py           # FFD, BFD, WFD, LPT
|   +-- dynamic_programming.py
|   +-- branch_and_bound.py
|   +-- metaheuristics.py   # SA, GA, Tabu
|   +-- approximation.py
+-- visualizations/
|   +-- plots.py            # Graficos estaticos
|   +-- animations.py       # Animaciones Manim/Plotly
|   +-- interactive.py      # Componentes interactivos
+-- theory/
|   +-- formalization.py
|   +-- complexity.py
|   +-- pseudocode.py
+-- benchmarks/
|   +-- runner.py
|   +-- instances.py
|   +-- analysis.py
+-- dashboard/
|   +-- app.py              # Aplicacion Streamlit
|   +-- components.py
+-- utils/
    +-- validators.py
    +-- exporters.py
    +-- helpers.py
\end{verbatim}

\subsection{Estructuras de Datos Principales}

\begin{lstlisting}[language=Python, caption=Estructuras de datos principales]
@dataclass
class Item:
    id: str
    weight: float
    value: float

@dataclass  
class Bin:
    id: int
    capacity: float  # Capacidad individual del bin
    items: List[Item] = field(default_factory=list)
    
    @property
    def remaining_capacity(self) -> float:
        return self.capacity - sum(item.weight for item in self.items)
    
    @property
    def total_value(self) -> float:
        return sum(item.value for item in self.items)

@dataclass
class Problem:
    items: List[Item]
    num_bins: int
    bin_capacities: List[float]  # Capacidades individuales por bin
    name: str = "unnamed"

@dataclass
class Solution:
    bins: List[Bin]
    objective: float = 0.0
\end{lstlisting}

%=============================================================================
\section{Resultados Experimentales}
%=============================================================================

\subsection{Configuración Experimental}

Los experimentos se realizaron con las siguientes configuraciones:
\begin{itemize}
    \item Instancias: 5 conjuntos de prueba (pequeñas, medianas, grandes, correlacionadas, bimodales)
    \item Métricas: Valor objetivo, tiempo de ejecución, tasa de factibilidad
    \item Repeticiones: 10 ejecuciones por algoritmo/instancia
    \item Límite de tiempo: 60 segundos por ejecución
\end{itemize}


\subsection{Análisis de Escalabilidad}

Los algoritmos greedy mantienen tiempos de ejecución sub-segundos incluso para instancias grandes ($n > 100$), mientras que las metaheurísticas requieren ajuste de parámetros para equilibrar calidad y tiempo. Branch and Bound solo es práctico para instancias pequeñas ($n < 20$).

%=============================================================================
\section{Conclusiones}
%=============================================================================

\subsection{Resumen}

Este proyecto presenta una implementación completa y un análisis exhaustivo del problema de Balanced Multi-Bin Packing with Capacity Constraints. Las principales contribuciones incluyen:

\begin{enumerate}
    \item Formalización matemática rigurosa del problema como ILP
    \item Demostración de NP-hardness mediante reducción desde PARTITION
    \item Implementación de 9 algoritmos con diferentes enfoques
    \item Framework de benchmarking con análisis estadístico
    \item Dashboard interactivo para experimentación
\end{enumerate}

\subsection{Trabajo Futuro}

Posibles extensiones del trabajo incluyen:
\begin{itemize}
    \item Implementación de más metaheurísticas (Ant Colony, Particle Swarm)
    \item Algoritmos híbridos (matheurísticas)
    \item Variantes multi-objetivo del problema
    \item Paralelización de algoritmos
    \item Integración con solvers comerciales (Gurobi, CPLEX)
\end{itemize}

%=============================================================================
\section*{Referencias}
%=============================================================================

\begin{thebibliography}{99}

\bibitem{garey1979}
Garey, M.R., \& Johnson, D.S. (1979).
\textit{Computers and Intractability: A Guide to the Theory of NP-Completeness}.
W.H. Freeman.

\bibitem{martello1990}
Martello, S., \& Toth, P. (1990).
\textit{Knapsack Problems: Algorithms and Computer Implementations}.
John Wiley \& Sons.

\bibitem{coffman1996}
Coffman, E.G., Garey, M.R., \& Johnson, D.S. (1996).
Approximation algorithms for bin packing: A survey.
\textit{Approximation Algorithms for NP-hard Problems}, 46-93.

\bibitem{kirkpatrick1983}
Kirkpatrick, S., Gelatt, C.D., \& Vecchi, M.P. (1983).
Optimization by simulated annealing.
\textit{Science}, 220(4598), 671-680.

\bibitem{glover1986}
Glover, F. (1986).
Future paths for integer programming and links to artificial intelligence.
\textit{Computers \& Operations Research}, 13(5), 533-549.

\bibitem{goldberg1989}
Goldberg, D.E. (1989).
\textit{Genetic Algorithms in Search, Optimization and Machine Learning}.
Addison-Wesley.

\bibitem{graham1969}
Graham, R.L. (1969).
Bounds on multiprocessing timing anomalies.
\textit{SIAM Journal on Applied Mathematics}, 17(2), 416-429.

\end{thebibliography}

%=============================================================================
\appendix
\section{Manual de Uso}
%=============================================================================

\subsection{Instalación}

\begin{lstlisting}[language=bash]
# Clonar repositorio
git clone <repository-url>
cd mulas

# Crear entorno virtual
python -m venv venv
source venv/bin/activate  # Linux/Mac
venv\Scripts\activate     # Windows

# Instalar dependencias
pip install -r requirements.txt
\end{lstlisting}

\subsection{Uso Básico}

\begin{lstlisting}[language=Python]
from discrete_logistics.core import Problem, Item
from discrete_logistics.algorithms import FirstFitDecreasing

# Crear problema con capacidades individuales por bin
items = [
    Item("i1", weight=10, value=20),
    Item("i2", weight=15, value=30),
    Item("i3", weight=8, value=15),
]

problem = Problem(
    items=items,
    num_bins=2,
    bin_capacities=[20.0, 25.0],  # Capacidades diferentes
    name="example"
)

# Resolver
algorithm = FirstFitDecreasing()
solution = algorithm.solve(problem)

# Ver resultado
print(f"Objetivo: {solution.objective}")
\end{lstlisting}

\subsection{Dashboard}

\begin{lstlisting}[language=bash]
# Ejecutar dashboard
cd discrete_logistics/dashboard
streamlit run app.py
\end{lstlisting}

\end{document}
